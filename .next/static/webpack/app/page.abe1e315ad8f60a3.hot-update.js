"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./services/observability.ts":
/*!***********************************!*\
  !*** ./services/observability.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   observability: function() { return /* binding */ observability; }\n/* harmony export */ });\n/* harmony import */ var _casperService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./casperService */ \"(app-pages-browser)/./services/casperService.ts\");\n// Observability Service for Casper Accelerate\n// Provides metrics, health checks, and logging utilities\n\nclass ObservabilityService {\n    /**\n     * Log a message with structured data\n     */ log(level, component, message, data) {\n        const entry = {\n            timestamp: Date.now(),\n            level,\n            component,\n            message,\n            data\n        };\n        this.logs.push(entry);\n        // Trim logs if exceeding max\n        if (this.logs.length > this.maxLogs) {\n            this.logs = this.logs.slice(-this.maxLogs);\n        }\n        // Also output to console with formatting\n        const prefix = \"[\".concat(new Date(entry.timestamp).toISOString(), \"] [\").concat(level.toUpperCase(), \"] [\").concat(component, \"]\");\n        switch(level){\n            case \"error\":\n                console.error(prefix, message, data || \"\");\n                break;\n            case \"warn\":\n                console.warn(prefix, message, data || \"\");\n                break;\n            case \"debug\":\n                if (true) {\n                    console.debug(prefix, message, data || \"\");\n                }\n                break;\n            default:\n                console.log(prefix, message, data || \"\");\n        }\n    }\n    /**\n     * Record a batch processing event\n     */ recordBatchProcessed(batchSize) {\n        this.metrics.totalBatches++;\n        this.metrics.totalTransactions += batchSize;\n        this.batchSizes.push(batchSize);\n        this.metrics.avgBatchSize = this.batchSizes.reduce((a, b)=>a + b, 0) / this.batchSizes.length;\n        this.log(\"info\", \"Sequencer\", \"Batch processed: \".concat(batchSize, \" transactions\"), {\n            totalBatches: this.metrics.totalBatches,\n            avgBatchSize: this.metrics.avgBatchSize.toFixed(2)\n        });\n    }\n    /**\n     * Record proof generation event\n     */ recordProofGenerated(generationTimeMs) {\n        this.metrics.totalProofsGenerated++;\n        this.proofTimes.push(generationTimeMs);\n        this.metrics.avgProofTimeMs = this.proofTimes.reduce((a, b)=>a + b, 0) / this.proofTimes.length;\n        this.log(\"info\", \"Prover\", \"Proof generated in \".concat(generationTimeMs, \"ms\"), {\n            totalProofs: this.metrics.totalProofsGenerated,\n            avgTime: this.metrics.avgProofTimeMs.toFixed(2)\n        });\n    }\n    /**\n     * Record L1 submission attempt\n     */ recordL1Submission(success, error) {\n        this.metrics.l1SubmissionsAttempted++;\n        if (success) {\n            this.metrics.l1SubmissionsSucceeded++;\n            this.log(\"info\", \"L1Bridge\", \"L1 submission succeeded\");\n        } else {\n            this.metrics.l1SubmissionFailures++;\n            this.log(\"error\", \"L1Bridge\", \"L1 submission failed\", {\n                error\n            });\n        }\n    }\n    /**\n     * Get current metrics\n     */ getMetrics() {\n        return {\n            ...this.metrics,\n            uptime: Date.now() - this.startTime\n        };\n    }\n    /**\n     * Get recent logs\n     */ getLogs() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100, level = arguments.length > 1 ? arguments[1] : void 0;\n        let filteredLogs = this.logs;\n        if (level) {\n            filteredLogs = this.logs.filter((l)=>l.level === level);\n        }\n        return filteredLogs.slice(-limit);\n    }\n    /**\n     * Run health checks\n     */ async checkHealth() {\n        var _checks_find;\n        const checks = [];\n        // 1. RPC Health Check\n        const rpcStart = Date.now();\n        try {\n            const stateRoot = await _casperService__WEBPACK_IMPORTED_MODULE_0__.CasperService.getStateRoot();\n            checks.push({\n                name: \"RPC Connectivity\",\n                status: stateRoot ? \"pass\" : \"warn\",\n                message: stateRoot ? \"Connected, state root: \".concat(stateRoot.substring(0, 16), \"...\") : \"No state root returned\",\n                latencyMs: Date.now() - rpcStart\n            });\n        } catch (error) {\n            checks.push({\n                name: \"RPC Connectivity\",\n                status: \"fail\",\n                message: error instanceof Error ? error.message : \"Unknown error\",\n                latencyMs: Date.now() - rpcStart\n            });\n        }\n        // 2. Contract Configuration Check\n        const config = _casperService__WEBPACK_IMPORTED_MODULE_0__.CasperService.getContractConfig();\n        checks.push({\n            name: \"Contract Configuration\",\n            status: config.isConfigured ? \"pass\" : \"warn\",\n            message: \"Contract: \".concat(config.contractHash)\n        });\n        // 3. Prover Status Check\n        const proverReady = this.metrics.totalProofsGenerated > 0 || this.metrics.totalBatches === 0;\n        checks.push({\n            name: \"Prover Service\",\n            status: proverReady ? \"pass\" : \"warn\",\n            message: proverReady ? \"\".concat(this.metrics.totalProofsGenerated, \" proofs generated\") : \"No proofs generated yet\"\n        });\n        // 4. Sequencer Throughput Check\n        const avgBatchTime = this.metrics.totalBatches > 0 ? (Date.now() - this.startTime) / this.metrics.totalBatches : 0;\n        checks.push({\n            name: \"Sequencer Throughput\",\n            status: \"pass\",\n            message: \"\".concat(this.metrics.totalBatches, \" batches, \").concat(this.metrics.totalTransactions, \" txs, avg \").concat((avgBatchTime / 1000).toFixed(1), \"s/batch\")\n        });\n        // 5. L1 Submission Success Rate\n        const successRate = this.metrics.l1SubmissionsAttempted > 0 ? this.metrics.l1SubmissionsSucceeded / this.metrics.l1SubmissionsAttempted * 100 : 100;\n        checks.push({\n            name: \"L1 Submission Rate\",\n            status: successRate >= 90 ? \"pass\" : successRate >= 50 ? \"warn\" : \"fail\",\n            message: \"\".concat(successRate.toFixed(1), \"% success (\").concat(this.metrics.l1SubmissionsSucceeded, \"/\").concat(this.metrics.l1SubmissionsAttempted, \")\")\n        });\n        // Determine overall status\n        const hasFailure = checks.some((c)=>c.status === \"fail\");\n        const hasWarning = checks.some((c)=>c.status === \"warn\");\n        const overallStatus = hasFailure ? \"unhealthy\" : hasWarning ? \"degraded\" : \"healthy\";\n        this.lastHealth = {\n            status: overallStatus,\n            rpcConnected: ((_checks_find = checks.find((c)=>c.name === \"RPC Connectivity\")) === null || _checks_find === void 0 ? void 0 : _checks_find.status) === \"pass\",\n            contractConfigured: config.isConfigured,\n            proverReady,\n            lastHealthCheck: Date.now(),\n            checks\n        };\n        this.log(overallStatus === \"healthy\" ? \"info\" : overallStatus === \"degraded\" ? \"warn\" : \"error\", \"Health\", \"System status: \".concat(overallStatus), {\n            checks: checks.map((c)=>({\n                    name: c.name,\n                    status: c.status\n                }))\n        });\n        return this.lastHealth;\n    }\n    /**\n     * Get last health check result (cached)\n     */ getLastHealth() {\n        return this.lastHealth;\n    }\n    /**\n     * Start periodic health checks\n     */ startHealthChecks() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30000;\n        if (this.healthCheckInterval) return;\n        this.log(\"info\", \"Health\", \"Starting health checks every \".concat(intervalMs / 1000, \"s\"));\n        this.checkHealth(); // Initial check\n        this.healthCheckInterval = setInterval(()=>{\n            this.checkHealth();\n        }, intervalMs);\n    }\n    /**\n     * Stop health checks\n     */ stopHealthChecks() {\n        if (this.healthCheckInterval) {\n            clearInterval(this.healthCheckInterval);\n            this.healthCheckInterval = null;\n            this.log(\"info\", \"Health\", \"Health checks stopped\");\n        }\n    }\n    /**\n     * Get formatted uptime string\n     */ getUptimeString() {\n        const uptime = Date.now() - this.startTime;\n        const hours = Math.floor(uptime / 3600000);\n        const minutes = Math.floor(uptime % 3600000 / 60000);\n        const seconds = Math.floor(uptime % 60000 / 1000);\n        return \"\".concat(hours, \"h \").concat(minutes, \"m \").concat(seconds, \"s\");\n    }\n    /**\n     * Export metrics in Prometheus format\n     */ getPrometheusMetrics() {\n        const m = this.getMetrics();\n        return [\n            \"# HELP casper_accelerate_batches_total Total number of batches processed\",\n            \"# TYPE casper_accelerate_batches_total counter\",\n            \"casper_accelerate_batches_total \".concat(m.totalBatches),\n            \"\",\n            \"# HELP casper_accelerate_transactions_total Total number of transactions\",\n            \"# TYPE casper_accelerate_transactions_total counter\",\n            \"casper_accelerate_transactions_total \".concat(m.totalTransactions),\n            \"\",\n            \"# HELP casper_accelerate_proofs_total Total number of proofs generated\",\n            \"# TYPE casper_accelerate_proofs_total counter\",\n            \"casper_accelerate_proofs_total \".concat(m.totalProofsGenerated),\n            \"\",\n            \"# HELP casper_accelerate_proof_time_avg_ms Average proof generation time\",\n            \"# TYPE casper_accelerate_proof_time_avg_ms gauge\",\n            \"casper_accelerate_proof_time_avg_ms \".concat(m.avgProofTimeMs.toFixed(2)),\n            \"\",\n            \"# HELP casper_accelerate_l1_submissions_total L1 submission attempts\",\n            \"# TYPE casper_accelerate_l1_submissions_total counter\",\n            'casper_accelerate_l1_submissions_total{result=\"success\"} '.concat(m.l1SubmissionsSucceeded),\n            'casper_accelerate_l1_submissions_total{result=\"failure\"} '.concat(m.l1SubmissionFailures),\n            \"\",\n            \"# HELP casper_accelerate_uptime_seconds System uptime in seconds\",\n            \"# TYPE casper_accelerate_uptime_seconds gauge\",\n            \"casper_accelerate_uptime_seconds \".concat((m.uptime / 1000).toFixed(0))\n        ].join(\"\\n\");\n    }\n    constructor(){\n        this.logs = [];\n        this.maxLogs = 1000;\n        this.metrics = {\n            totalBatches: 0,\n            totalTransactions: 0,\n            totalProofsGenerated: 0,\n            avgProofTimeMs: 0,\n            avgBatchSize: 0,\n            l1SubmissionsAttempted: 0,\n            l1SubmissionsSucceeded: 0,\n            l1SubmissionFailures: 0,\n            uptime: 0\n        };\n        this.proofTimes = [];\n        this.batchSizes = [];\n        this.healthCheckInterval = null;\n        this.lastHealth = null;\n        this.startTime = Date.now();\n        this.log(\"info\", \"Observability\", \"Service initialized\");\n    }\n}\n// Singleton instance\nconst observability = new ObservabilityService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL29ic2VydmFiaWxpdHkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw4Q0FBOEM7QUFDOUMseURBQXlEO0FBRVQ7QUF1Q2hELE1BQU1DO0lBeUJGOztLQUVDLEdBQ0RDLElBQUlDLEtBQXdCLEVBQUVDLFNBQWlCLEVBQUVDLE9BQWUsRUFBRUMsSUFBVSxFQUFFO1FBQzFFLE1BQU1DLFFBQWtCO1lBQ3BCQyxXQUFXQyxLQUFLQyxHQUFHO1lBQ25CUDtZQUNBQztZQUNBQztZQUNBQztRQUNKO1FBRUEsSUFBSSxDQUFDSyxJQUFJLENBQUNDLElBQUksQ0FBQ0w7UUFFZiw2QkFBNkI7UUFDN0IsSUFBSSxJQUFJLENBQUNJLElBQUksQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ0MsT0FBTyxFQUFFO1lBQ2pDLElBQUksQ0FBQ0gsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxDQUFDSSxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUNELE9BQU87UUFDN0M7UUFFQSx5Q0FBeUM7UUFDekMsTUFBTUUsU0FBUyxJQUFpRGIsT0FBN0MsSUFBSU0sS0FBS0YsTUFBTUMsU0FBUyxFQUFFUyxXQUFXLElBQUcsT0FBOEJiLE9BQXpCRCxNQUFNZSxXQUFXLElBQUcsT0FBZSxPQUFWZCxXQUFVO1FBQ25HLE9BQVFEO1lBQ0osS0FBSztnQkFDRGdCLFFBQVFDLEtBQUssQ0FBQ0osUUFBUVgsU0FBU0MsUUFBUTtnQkFDdkM7WUFDSixLQUFLO2dCQUNEYSxRQUFRRSxJQUFJLENBQUNMLFFBQVFYLFNBQVNDLFFBQVE7Z0JBQ3RDO1lBQ0osS0FBSztnQkFDRCxJQUFJZ0IsSUFBeUIsRUFBZTtvQkFDeENILFFBQVFJLEtBQUssQ0FBQ1AsUUFBUVgsU0FBU0MsUUFBUTtnQkFDM0M7Z0JBQ0E7WUFDSjtnQkFDSWEsUUFBUWpCLEdBQUcsQ0FBQ2MsUUFBUVgsU0FBU0MsUUFBUTtRQUM3QztJQUNKO0lBRUE7O0tBRUMsR0FDRGtCLHFCQUFxQkMsU0FBaUIsRUFBRTtRQUNwQyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsWUFBWTtRQUN6QixJQUFJLENBQUNELE9BQU8sQ0FBQ0UsaUJBQWlCLElBQUlIO1FBQ2xDLElBQUksQ0FBQ0ksVUFBVSxDQUFDakIsSUFBSSxDQUFDYTtRQUNyQixJQUFJLENBQUNDLE9BQU8sQ0FBQ0ksWUFBWSxHQUFHLElBQUksQ0FBQ0QsVUFBVSxDQUFDRSxNQUFNLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUMsR0FBRyxLQUFLLElBQUksQ0FBQ0osVUFBVSxDQUFDaEIsTUFBTTtRQUUvRixJQUFJLENBQUNYLEdBQUcsQ0FBQyxRQUFRLGFBQWEsb0JBQThCLE9BQVZ1QixXQUFVLGtCQUFnQjtZQUN4RUUsY0FBYyxJQUFJLENBQUNELE9BQU8sQ0FBQ0MsWUFBWTtZQUN2Q0csY0FBYyxJQUFJLENBQUNKLE9BQU8sQ0FBQ0ksWUFBWSxDQUFDSSxPQUFPLENBQUM7UUFDcEQ7SUFDSjtJQUVBOztLQUVDLEdBQ0RDLHFCQUFxQkMsZ0JBQXdCLEVBQUU7UUFDM0MsSUFBSSxDQUFDVixPQUFPLENBQUNXLG9CQUFvQjtRQUNqQyxJQUFJLENBQUNDLFVBQVUsQ0FBQzFCLElBQUksQ0FBQ3dCO1FBQ3JCLElBQUksQ0FBQ1YsT0FBTyxDQUFDYSxjQUFjLEdBQUcsSUFBSSxDQUFDRCxVQUFVLENBQUNQLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQyxHQUFHLEtBQUssSUFBSSxDQUFDSyxVQUFVLENBQUN6QixNQUFNO1FBRWpHLElBQUksQ0FBQ1gsR0FBRyxDQUFDLFFBQVEsVUFBVSxzQkFBdUMsT0FBakJrQyxrQkFBaUIsT0FBSztZQUNuRUksYUFBYSxJQUFJLENBQUNkLE9BQU8sQ0FBQ1csb0JBQW9CO1lBQzlDSSxTQUFTLElBQUksQ0FBQ2YsT0FBTyxDQUFDYSxjQUFjLENBQUNMLE9BQU8sQ0FBQztRQUNqRDtJQUNKO0lBRUE7O0tBRUMsR0FDRFEsbUJBQW1CQyxPQUFnQixFQUFFdkIsS0FBYyxFQUFFO1FBQ2pELElBQUksQ0FBQ00sT0FBTyxDQUFDa0Isc0JBQXNCO1FBQ25DLElBQUlELFNBQVM7WUFDVCxJQUFJLENBQUNqQixPQUFPLENBQUNtQixzQkFBc0I7WUFDbkMsSUFBSSxDQUFDM0MsR0FBRyxDQUFDLFFBQVEsWUFBWTtRQUNqQyxPQUFPO1lBQ0gsSUFBSSxDQUFDd0IsT0FBTyxDQUFDb0Isb0JBQW9CO1lBQ2pDLElBQUksQ0FBQzVDLEdBQUcsQ0FBQyxTQUFTLFlBQVksd0JBQXdCO2dCQUFFa0I7WUFBTTtRQUNsRTtJQUNKO0lBRUE7O0tBRUMsR0FDRDJCLGFBQStCO1FBQzNCLE9BQU87WUFDSCxHQUFHLElBQUksQ0FBQ3JCLE9BQU87WUFDZnNCLFFBQVF2QyxLQUFLQyxHQUFHLEtBQUssSUFBSSxDQUFDdUMsU0FBUztRQUN2QztJQUNKO0lBRUE7O0tBRUMsR0FDREMsVUFBNEQ7WUFBcERDLFFBQUFBLGlFQUFRLEtBQUtoRDtRQUNqQixJQUFJaUQsZUFBZSxJQUFJLENBQUN6QyxJQUFJO1FBQzVCLElBQUlSLE9BQU87WUFDUGlELGVBQWUsSUFBSSxDQUFDekMsSUFBSSxDQUFDMEMsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFbkQsS0FBSyxLQUFLQTtRQUNyRDtRQUNBLE9BQU9pRCxhQUFhckMsS0FBSyxDQUFDLENBQUNvQztJQUMvQjtJQUVBOztLQUVDLEdBQ0QsTUFBTUksY0FBcUM7WUFpRXJCQztRQWhFbEIsTUFBTUEsU0FBd0IsRUFBRTtRQUVoQyxzQkFBc0I7UUFDdEIsTUFBTUMsV0FBV2hELEtBQUtDLEdBQUc7UUFDekIsSUFBSTtZQUNBLE1BQU1nRCxZQUFZLE1BQU0xRCx5REFBYUEsQ0FBQzJELFlBQVk7WUFDbERILE9BQU81QyxJQUFJLENBQUM7Z0JBQ1JnRCxNQUFNO2dCQUNOQyxRQUFRSCxZQUFZLFNBQVM7Z0JBQzdCckQsU0FBU3FELFlBQVksMEJBQXFELE9BQTNCQSxVQUFVSSxTQUFTLENBQUMsR0FBRyxLQUFJLFNBQU87Z0JBQ2pGQyxXQUFXdEQsS0FBS0MsR0FBRyxLQUFLK0M7WUFDNUI7UUFDSixFQUFFLE9BQU9yQyxPQUFPO1lBQ1pvQyxPQUFPNUMsSUFBSSxDQUFDO2dCQUNSZ0QsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUnhELFNBQVNlLGlCQUFpQjRDLFFBQVE1QyxNQUFNZixPQUFPLEdBQUc7Z0JBQ2xEMEQsV0FBV3RELEtBQUtDLEdBQUcsS0FBSytDO1lBQzVCO1FBQ0o7UUFFQSxrQ0FBa0M7UUFDbEMsTUFBTVEsU0FBU2pFLHlEQUFhQSxDQUFDa0UsaUJBQWlCO1FBQzlDVixPQUFPNUMsSUFBSSxDQUFDO1lBQ1JnRCxNQUFNO1lBQ05DLFFBQVFJLE9BQU9FLFlBQVksR0FBRyxTQUFTO1lBQ3ZDOUQsU0FBUyxhQUFpQyxPQUFwQjRELE9BQU9HLFlBQVk7UUFDN0M7UUFFQSx5QkFBeUI7UUFDekIsTUFBTUMsY0FBYyxJQUFJLENBQUMzQyxPQUFPLENBQUNXLG9CQUFvQixHQUFHLEtBQUssSUFBSSxDQUFDWCxPQUFPLENBQUNDLFlBQVksS0FBSztRQUMzRjZCLE9BQU81QyxJQUFJLENBQUM7WUFDUmdELE1BQU07WUFDTkMsUUFBUVEsY0FBYyxTQUFTO1lBQy9CaEUsU0FBU2dFLGNBQWMsR0FBcUMsT0FBbEMsSUFBSSxDQUFDM0MsT0FBTyxDQUFDVyxvQkFBb0IsRUFBQyx1QkFBcUI7UUFDckY7UUFFQSxnQ0FBZ0M7UUFDaEMsTUFBTWlDLGVBQWUsSUFBSSxDQUFDNUMsT0FBTyxDQUFDQyxZQUFZLEdBQUcsSUFDM0MsQ0FBQ2xCLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUN1QyxTQUFTLElBQUksSUFBSSxDQUFDdkIsT0FBTyxDQUFDQyxZQUFZLEdBQ3pEO1FBQ042QixPQUFPNUMsSUFBSSxDQUFDO1lBQ1JnRCxNQUFNO1lBQ05DLFFBQVE7WUFDUnhELFNBQVMsR0FBeUMsT0FBdEMsSUFBSSxDQUFDcUIsT0FBTyxDQUFDQyxZQUFZLEVBQUMsY0FBdUQsT0FBM0MsSUFBSSxDQUFDRCxPQUFPLENBQUNFLGlCQUFpQixFQUFDLGNBQTZDLE9BQWpDLENBQUMwQyxlQUFlLElBQUcsRUFBR3BDLE9BQU8sQ0FBQyxJQUFHO1FBQ2xJO1FBRUEsZ0NBQWdDO1FBQ2hDLE1BQU1xQyxjQUFjLElBQUksQ0FBQzdDLE9BQU8sQ0FBQ2tCLHNCQUFzQixHQUFHLElBQ3BELElBQUssQ0FBQ2xCLE9BQU8sQ0FBQ21CLHNCQUFzQixHQUFHLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ2tCLHNCQUFzQixHQUFJLE1BQzlFO1FBQ05ZLE9BQU81QyxJQUFJLENBQUM7WUFDUmdELE1BQU07WUFDTkMsUUFBUVUsZUFBZSxLQUFLLFNBQVNBLGVBQWUsS0FBSyxTQUFTO1lBQ2xFbEUsU0FBUyxHQUF1QyxPQUFwQ2tFLFlBQVlyQyxPQUFPLENBQUMsSUFBRyxlQUFvRCxPQUF2QyxJQUFJLENBQUNSLE9BQU8sQ0FBQ21CLHNCQUFzQixFQUFDLEtBQXVDLE9BQXBDLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ2tCLHNCQUFzQixFQUFDO1FBQy9IO1FBRUEsMkJBQTJCO1FBQzNCLE1BQU00QixhQUFhaEIsT0FBT2lCLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRWIsTUFBTSxLQUFLO1FBQ2pELE1BQU1jLGFBQWFuQixPQUFPaUIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFYixNQUFNLEtBQUs7UUFDakQsTUFBTWUsZ0JBQXdDSixhQUFhLGNBQWNHLGFBQWEsYUFBYTtRQUVuRyxJQUFJLENBQUNFLFVBQVUsR0FBRztZQUNkaEIsUUFBUWU7WUFDUkUsY0FBY3RCLEVBQUFBLGVBQUFBLE9BQU91QixJQUFJLENBQUNMLENBQUFBLElBQUtBLEVBQUVkLElBQUksS0FBSyxpQ0FBNUJKLG1DQUFBQSxhQUFpREssTUFBTSxNQUFLO1lBQzFFbUIsb0JBQW9CZixPQUFPRSxZQUFZO1lBQ3ZDRTtZQUNBWSxpQkFBaUJ4RSxLQUFLQyxHQUFHO1lBQ3pCOEM7UUFDSjtRQUVBLElBQUksQ0FBQ3RELEdBQUcsQ0FDSjBFLGtCQUFrQixZQUFZLFNBQVNBLGtCQUFrQixhQUFhLFNBQVMsU0FDL0UsVUFDQSxrQkFBZ0MsT0FBZEEsZ0JBQ2xCO1lBQUVwQixRQUFRQSxPQUFPMEIsR0FBRyxDQUFDUixDQUFBQSxJQUFNO29CQUFFZCxNQUFNYyxFQUFFZCxJQUFJO29CQUFFQyxRQUFRYSxFQUFFYixNQUFNO2dCQUFDO1FBQUk7UUFHcEUsT0FBTyxJQUFJLENBQUNnQixVQUFVO0lBQzFCO0lBRUE7O0tBRUMsR0FDRE0sZ0JBQXFDO1FBQ2pDLE9BQU8sSUFBSSxDQUFDTixVQUFVO0lBQzFCO0lBRUE7O0tBRUMsR0FDRE8sb0JBQXNDO1lBQXBCQyxhQUFBQSxpRUFBYTtRQUMzQixJQUFJLElBQUksQ0FBQ0MsbUJBQW1CLEVBQUU7UUFFOUIsSUFBSSxDQUFDcEYsR0FBRyxDQUFDLFFBQVEsVUFBVSxnQ0FBa0QsT0FBbEJtRixhQUFhLE1BQUs7UUFDN0UsSUFBSSxDQUFDOUIsV0FBVyxJQUFJLGdCQUFnQjtRQUVwQyxJQUFJLENBQUMrQixtQkFBbUIsR0FBR0MsWUFBWTtZQUNuQyxJQUFJLENBQUNoQyxXQUFXO1FBQ3BCLEdBQUc4QjtJQUNQO0lBRUE7O0tBRUMsR0FDREcsbUJBQW1CO1FBQ2YsSUFBSSxJQUFJLENBQUNGLG1CQUFtQixFQUFFO1lBQzFCRyxjQUFjLElBQUksQ0FBQ0gsbUJBQW1CO1lBQ3RDLElBQUksQ0FBQ0EsbUJBQW1CLEdBQUc7WUFDM0IsSUFBSSxDQUFDcEYsR0FBRyxDQUFDLFFBQVEsVUFBVTtRQUMvQjtJQUNKO0lBRUE7O0tBRUMsR0FDRHdGLGtCQUEwQjtRQUN0QixNQUFNMUMsU0FBU3ZDLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUN1QyxTQUFTO1FBQzFDLE1BQU0wQyxRQUFRQyxLQUFLQyxLQUFLLENBQUM3QyxTQUFTO1FBQ2xDLE1BQU04QyxVQUFVRixLQUFLQyxLQUFLLENBQUMsU0FBVSxVQUFXO1FBQ2hELE1BQU1FLFVBQVVILEtBQUtDLEtBQUssQ0FBQyxTQUFVLFFBQVM7UUFDOUMsT0FBTyxHQUFhQyxPQUFWSCxPQUFNLE1BQWdCSSxPQUFaRCxTQUFRLE1BQVksT0FBUkMsU0FBUTtJQUM1QztJQUVBOztLQUVDLEdBQ0RDLHVCQUErQjtRQUMzQixNQUFNQyxJQUFJLElBQUksQ0FBQ2xELFVBQVU7UUFDekIsT0FBTztZQUNIO1lBQ0E7WUFDQyxtQ0FBaUQsT0FBZmtELEVBQUV0RSxZQUFZO1lBQ2pEO1lBQ0E7WUFDQTtZQUNDLHdDQUEyRCxPQUFwQnNFLEVBQUVyRSxpQkFBaUI7WUFDM0Q7WUFDQTtZQUNBO1lBQ0Msa0NBQXdELE9BQXZCcUUsRUFBRTVELG9CQUFvQjtZQUN4RDtZQUNBO1lBQ0E7WUFDQyx1Q0FBa0UsT0FBNUI0RCxFQUFFMUQsY0FBYyxDQUFDTCxPQUFPLENBQUM7WUFDaEU7WUFDQTtZQUNBO1lBQ0MsNERBQW9GLE9BQXpCK0QsRUFBRXBELHNCQUFzQjtZQUNuRiw0REFBa0YsT0FBdkJvRCxFQUFFbkQsb0JBQW9CO1lBQ2xGO1lBQ0E7WUFDQTtZQUNDLG9DQUFnRSxPQUE3QixDQUFDbUQsRUFBRWpELE1BQU0sR0FBRyxJQUFHLEVBQUdkLE9BQU8sQ0FBQztTQUNqRSxDQUFDZ0UsSUFBSSxDQUFDO0lBQ1g7SUExUUFDLGFBQWM7YUFsQk54RixPQUFtQixFQUFFO2FBQ3JCRyxVQUFVO2FBQ1ZZLFVBQTRCO1lBQ2hDQyxjQUFjO1lBQ2RDLG1CQUFtQjtZQUNuQlMsc0JBQXNCO1lBQ3RCRSxnQkFBZ0I7WUFDaEJULGNBQWM7WUFDZGMsd0JBQXdCO1lBQ3hCQyx3QkFBd0I7WUFDeEJDLHNCQUFzQjtZQUN0QkUsUUFBUTtRQUNaO2FBQ1FWLGFBQXVCLEVBQUU7YUFDekJULGFBQXVCLEVBQUU7YUFDekJ5RCxzQkFBNkM7YUFDN0NULGFBQWtDO1FBR3RDLElBQUksQ0FBQzVCLFNBQVMsR0FBR3hDLEtBQUtDLEdBQUc7UUFDekIsSUFBSSxDQUFDUixHQUFHLENBQUMsUUFBUSxpQkFBaUI7SUFDdEM7QUF3UUo7QUFFQSxxQkFBcUI7QUFDZCxNQUFNa0csZ0JBQWdCLElBQUluRyx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc2VydmljZXMvb2JzZXJ2YWJpbGl0eS50cz8xNDdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9ic2VydmFiaWxpdHkgU2VydmljZSBmb3IgQ2FzcGVyIEFjY2VsZXJhdGVcbi8vIFByb3ZpZGVzIG1ldHJpY3MsIGhlYWx0aCBjaGVja3MsIGFuZCBsb2dnaW5nIHV0aWxpdGllc1xuXG5pbXBvcnQgeyBDYXNwZXJTZXJ2aWNlIH0gZnJvbSAnLi9jYXNwZXJTZXJ2aWNlJztcblxuLy8gTWV0cmljcyB0eXBlc1xuZXhwb3J0IGludGVyZmFjZSBTZXF1ZW5jZXJNZXRyaWNzIHtcbiAgICB0b3RhbEJhdGNoZXM6IG51bWJlcjtcbiAgICB0b3RhbFRyYW5zYWN0aW9uczogbnVtYmVyO1xuICAgIHRvdGFsUHJvb2ZzR2VuZXJhdGVkOiBudW1iZXI7XG4gICAgYXZnUHJvb2ZUaW1lTXM6IG51bWJlcjtcbiAgICBhdmdCYXRjaFNpemU6IG51bWJlcjtcbiAgICBsMVN1Ym1pc3Npb25zQXR0ZW1wdGVkOiBudW1iZXI7XG4gICAgbDFTdWJtaXNzaW9uc1N1Y2NlZWRlZDogbnVtYmVyO1xuICAgIGwxU3VibWlzc2lvbkZhaWx1cmVzOiBudW1iZXI7XG4gICAgdXB0aW1lOiBudW1iZXI7IC8vIG1pbGxpc2Vjb25kc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5c3RlbUhlYWx0aCB7XG4gICAgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSc7XG4gICAgcnBjQ29ubmVjdGVkOiBib29sZWFuO1xuICAgIGNvbnRyYWN0Q29uZmlndXJlZDogYm9vbGVhbjtcbiAgICBwcm92ZXJSZWFkeTogYm9vbGVhbjtcbiAgICBsYXN0SGVhbHRoQ2hlY2s6IG51bWJlcjtcbiAgICBjaGVja3M6IEhlYWx0aENoZWNrW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQ2hlY2sge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzdGF0dXM6ICdwYXNzJyB8ICdmYWlsJyB8ICd3YXJuJztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgbGF0ZW5jeU1zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ0VudHJ5IHtcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICBsZXZlbDogJ2RlYnVnJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcic7XG4gICAgY29tcG9uZW50OiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIGRhdGE/OiBhbnk7XG59XG5cbmNsYXNzIE9ic2VydmFiaWxpdHlTZXJ2aWNlIHtcbiAgICBwcml2YXRlIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgIHByaXZhdGUgbG9nczogTG9nRW50cnlbXSA9IFtdO1xuICAgIHByaXZhdGUgbWF4TG9ncyA9IDEwMDA7XG4gICAgcHJpdmF0ZSBtZXRyaWNzOiBTZXF1ZW5jZXJNZXRyaWNzID0ge1xuICAgICAgICB0b3RhbEJhdGNoZXM6IDAsXG4gICAgICAgIHRvdGFsVHJhbnNhY3Rpb25zOiAwLFxuICAgICAgICB0b3RhbFByb29mc0dlbmVyYXRlZDogMCxcbiAgICAgICAgYXZnUHJvb2ZUaW1lTXM6IDAsXG4gICAgICAgIGF2Z0JhdGNoU2l6ZTogMCxcbiAgICAgICAgbDFTdWJtaXNzaW9uc0F0dGVtcHRlZDogMCxcbiAgICAgICAgbDFTdWJtaXNzaW9uc1N1Y2NlZWRlZDogMCxcbiAgICAgICAgbDFTdWJtaXNzaW9uRmFpbHVyZXM6IDAsXG4gICAgICAgIHVwdGltZTogMFxuICAgIH07XG4gICAgcHJpdmF0ZSBwcm9vZlRpbWVzOiBudW1iZXJbXSA9IFtdO1xuICAgIHByaXZhdGUgYmF0Y2hTaXplczogbnVtYmVyW10gPSBbXTtcbiAgICBwcml2YXRlIGhlYWx0aENoZWNrSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBsYXN0SGVhbHRoOiBTeXN0ZW1IZWFsdGggfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMubG9nKCdpbmZvJywgJ09ic2VydmFiaWxpdHknLCAnU2VydmljZSBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvZyBhIG1lc3NhZ2Ugd2l0aCBzdHJ1Y3R1cmVkIGRhdGFcbiAgICAgKi9cbiAgICBsb2cobGV2ZWw6IExvZ0VudHJ5WydsZXZlbCddLCBjb21wb25lbnQ6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCBkYXRhPzogYW55KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5OiBMb2dFbnRyeSA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmxvZ3MucHVzaChlbnRyeSk7XG5cbiAgICAgICAgLy8gVHJpbSBsb2dzIGlmIGV4Y2VlZGluZyBtYXhcbiAgICAgICAgaWYgKHRoaXMubG9ncy5sZW5ndGggPiB0aGlzLm1heExvZ3MpIHtcbiAgICAgICAgICAgIHRoaXMubG9ncyA9IHRoaXMubG9ncy5zbGljZSgtdGhpcy5tYXhMb2dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsc28gb3V0cHV0IHRvIGNvbnNvbGUgd2l0aCBmb3JtYXR0aW5nXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGBbJHtuZXcgRGF0ZShlbnRyeS50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCl9XSBbJHtsZXZlbC50b1VwcGVyQ2FzZSgpfV0gWyR7Y29tcG9uZW50fV1gO1xuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihwcmVmaXgsIG1lc3NhZ2UsIGRhdGEgfHwgJycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHByZWZpeCwgbWVzc2FnZSwgZGF0YSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZWJ1Zyc6XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcocHJlZml4LCBtZXNzYWdlLCBkYXRhIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHByZWZpeCwgbWVzc2FnZSwgZGF0YSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNvcmQgYSBiYXRjaCBwcm9jZXNzaW5nIGV2ZW50XG4gICAgICovXG4gICAgcmVjb3JkQmF0Y2hQcm9jZXNzZWQoYmF0Y2hTaXplOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsQmF0Y2hlcysrO1xuICAgICAgICB0aGlzLm1ldHJpY3MudG90YWxUcmFuc2FjdGlvbnMgKz0gYmF0Y2hTaXplO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZXMucHVzaChiYXRjaFNpemUpO1xuICAgICAgICB0aGlzLm1ldHJpY3MuYXZnQmF0Y2hTaXplID0gdGhpcy5iYXRjaFNpemVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gdGhpcy5iYXRjaFNpemVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLmxvZygnaW5mbycsICdTZXF1ZW5jZXInLCBgQmF0Y2ggcHJvY2Vzc2VkOiAke2JhdGNoU2l6ZX0gdHJhbnNhY3Rpb25zYCwge1xuICAgICAgICAgICAgdG90YWxCYXRjaGVzOiB0aGlzLm1ldHJpY3MudG90YWxCYXRjaGVzLFxuICAgICAgICAgICAgYXZnQmF0Y2hTaXplOiB0aGlzLm1ldHJpY3MuYXZnQmF0Y2hTaXplLnRvRml4ZWQoMilcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjb3JkIHByb29mIGdlbmVyYXRpb24gZXZlbnRcbiAgICAgKi9cbiAgICByZWNvcmRQcm9vZkdlbmVyYXRlZChnZW5lcmF0aW9uVGltZU1zOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5tZXRyaWNzLnRvdGFsUHJvb2ZzR2VuZXJhdGVkKys7XG4gICAgICAgIHRoaXMucHJvb2ZUaW1lcy5wdXNoKGdlbmVyYXRpb25UaW1lTXMpO1xuICAgICAgICB0aGlzLm1ldHJpY3MuYXZnUHJvb2ZUaW1lTXMgPSB0aGlzLnByb29mVGltZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyB0aGlzLnByb29mVGltZXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMubG9nKCdpbmZvJywgJ1Byb3ZlcicsIGBQcm9vZiBnZW5lcmF0ZWQgaW4gJHtnZW5lcmF0aW9uVGltZU1zfW1zYCwge1xuICAgICAgICAgICAgdG90YWxQcm9vZnM6IHRoaXMubWV0cmljcy50b3RhbFByb29mc0dlbmVyYXRlZCxcbiAgICAgICAgICAgIGF2Z1RpbWU6IHRoaXMubWV0cmljcy5hdmdQcm9vZlRpbWVNcy50b0ZpeGVkKDIpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY29yZCBMMSBzdWJtaXNzaW9uIGF0dGVtcHRcbiAgICAgKi9cbiAgICByZWNvcmRMMVN1Ym1pc3Npb24oc3VjY2VzczogYm9vbGVhbiwgZXJyb3I/OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5tZXRyaWNzLmwxU3VibWlzc2lvbnNBdHRlbXB0ZWQrKztcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubWV0cmljcy5sMVN1Ym1pc3Npb25zU3VjY2VlZGVkKys7XG4gICAgICAgICAgICB0aGlzLmxvZygnaW5mbycsICdMMUJyaWRnZScsICdMMSBzdWJtaXNzaW9uIHN1Y2NlZWRlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXRyaWNzLmwxU3VibWlzc2lvbkZhaWx1cmVzKys7XG4gICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnTDFCcmlkZ2UnLCAnTDEgc3VibWlzc2lvbiBmYWlsZWQnLCB7IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgbWV0cmljc1xuICAgICAqL1xuICAgIGdldE1ldHJpY3MoKTogU2VxdWVuY2VyTWV0cmljcyB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLm1ldHJpY3MsXG4gICAgICAgICAgICB1cHRpbWU6IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCByZWNlbnQgbG9nc1xuICAgICAqL1xuICAgIGdldExvZ3MobGltaXQgPSAxMDAsIGxldmVsPzogTG9nRW50cnlbJ2xldmVsJ10pOiBMb2dFbnRyeVtdIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkTG9ncyA9IHRoaXMubG9ncztcbiAgICAgICAgaWYgKGxldmVsKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZExvZ3MgPSB0aGlzLmxvZ3MuZmlsdGVyKGwgPT4gbC5sZXZlbCA9PT0gbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZExvZ3Muc2xpY2UoLWxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gaGVhbHRoIGNoZWNrc1xuICAgICAqL1xuICAgIGFzeW5jIGNoZWNrSGVhbHRoKCk6IFByb21pc2U8U3lzdGVtSGVhbHRoPiB7XG4gICAgICAgIGNvbnN0IGNoZWNrczogSGVhbHRoQ2hlY2tbXSA9IFtdO1xuXG4gICAgICAgIC8vIDEuIFJQQyBIZWFsdGggQ2hlY2tcbiAgICAgICAgY29uc3QgcnBjU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVSb290ID0gYXdhaXQgQ2FzcGVyU2VydmljZS5nZXRTdGF0ZVJvb3QoKTtcbiAgICAgICAgICAgIGNoZWNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnUlBDIENvbm5lY3Rpdml0eScsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0ZVJvb3QgPyAncGFzcycgOiAnd2FybicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogc3RhdGVSb290ID8gYENvbm5lY3RlZCwgc3RhdGUgcm9vdDogJHtzdGF0ZVJvb3Quc3Vic3RyaW5nKDAsIDE2KX0uLi5gIDogJ05vIHN0YXRlIHJvb3QgcmV0dXJuZWQnLFxuICAgICAgICAgICAgICAgIGxhdGVuY3lNczogRGF0ZS5ub3coKSAtIHJwY1N0YXJ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNoZWNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnUlBDIENvbm5lY3Rpdml0eScsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZmFpbCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICAgICAgbGF0ZW5jeU1zOiBEYXRlLm5vdygpIC0gcnBjU3RhcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gQ29udHJhY3QgQ29uZmlndXJhdGlvbiBDaGVja1xuICAgICAgICBjb25zdCBjb25maWcgPSBDYXNwZXJTZXJ2aWNlLmdldENvbnRyYWN0Q29uZmlnKCk7XG4gICAgICAgIGNoZWNrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6ICdDb250cmFjdCBDb25maWd1cmF0aW9uJyxcbiAgICAgICAgICAgIHN0YXR1czogY29uZmlnLmlzQ29uZmlndXJlZCA/ICdwYXNzJyA6ICd3YXJuJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBDb250cmFjdDogJHtjb25maWcuY29udHJhY3RIYXNofWBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gMy4gUHJvdmVyIFN0YXR1cyBDaGVja1xuICAgICAgICBjb25zdCBwcm92ZXJSZWFkeSA9IHRoaXMubWV0cmljcy50b3RhbFByb29mc0dlbmVyYXRlZCA+IDAgfHwgdGhpcy5tZXRyaWNzLnRvdGFsQmF0Y2hlcyA9PT0gMDtcbiAgICAgICAgY2hlY2tzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogJ1Byb3ZlciBTZXJ2aWNlJyxcbiAgICAgICAgICAgIHN0YXR1czogcHJvdmVyUmVhZHkgPyAncGFzcycgOiAnd2FybicsXG4gICAgICAgICAgICBtZXNzYWdlOiBwcm92ZXJSZWFkeSA/IGAke3RoaXMubWV0cmljcy50b3RhbFByb29mc0dlbmVyYXRlZH0gcHJvb2ZzIGdlbmVyYXRlZGAgOiAnTm8gcHJvb2ZzIGdlbmVyYXRlZCB5ZXQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIDQuIFNlcXVlbmNlciBUaHJvdWdocHV0IENoZWNrXG4gICAgICAgIGNvbnN0IGF2Z0JhdGNoVGltZSA9IHRoaXMubWV0cmljcy50b3RhbEJhdGNoZXMgPiAwXG4gICAgICAgICAgICA/IChEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUpIC8gdGhpcy5tZXRyaWNzLnRvdGFsQmF0Y2hlc1xuICAgICAgICAgICAgOiAwO1xuICAgICAgICBjaGVja3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiAnU2VxdWVuY2VyIFRocm91Z2hwdXQnLFxuICAgICAgICAgICAgc3RhdHVzOiAncGFzcycsXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHt0aGlzLm1ldHJpY3MudG90YWxCYXRjaGVzfSBiYXRjaGVzLCAke3RoaXMubWV0cmljcy50b3RhbFRyYW5zYWN0aW9uc30gdHhzLCBhdmcgJHsoYXZnQmF0Y2hUaW1lIC8gMTAwMCkudG9GaXhlZCgxKX1zL2JhdGNoYFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyA1LiBMMSBTdWJtaXNzaW9uIFN1Y2Nlc3MgUmF0ZVxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHRoaXMubWV0cmljcy5sMVN1Ym1pc3Npb25zQXR0ZW1wdGVkID4gMFxuICAgICAgICAgICAgPyAodGhpcy5tZXRyaWNzLmwxU3VibWlzc2lvbnNTdWNjZWVkZWQgLyB0aGlzLm1ldHJpY3MubDFTdWJtaXNzaW9uc0F0dGVtcHRlZCkgKiAxMDBcbiAgICAgICAgICAgIDogMTAwO1xuICAgICAgICBjaGVja3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiAnTDEgU3VibWlzc2lvbiBSYXRlJyxcbiAgICAgICAgICAgIHN0YXR1czogc3VjY2Vzc1JhdGUgPj0gOTAgPyAncGFzcycgOiBzdWNjZXNzUmF0ZSA+PSA1MCA/ICd3YXJuJyA6ICdmYWlsJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGAke3N1Y2Nlc3NSYXRlLnRvRml4ZWQoMSl9JSBzdWNjZXNzICgke3RoaXMubWV0cmljcy5sMVN1Ym1pc3Npb25zU3VjY2VlZGVkfS8ke3RoaXMubWV0cmljcy5sMVN1Ym1pc3Npb25zQXR0ZW1wdGVkfSlgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERldGVybWluZSBvdmVyYWxsIHN0YXR1c1xuICAgICAgICBjb25zdCBoYXNGYWlsdXJlID0gY2hlY2tzLnNvbWUoYyA9PiBjLnN0YXR1cyA9PT0gJ2ZhaWwnKTtcbiAgICAgICAgY29uc3QgaGFzV2FybmluZyA9IGNoZWNrcy5zb21lKGMgPT4gYy5zdGF0dXMgPT09ICd3YXJuJyk7XG4gICAgICAgIGNvbnN0IG92ZXJhbGxTdGF0dXM6IFN5c3RlbUhlYWx0aFsnc3RhdHVzJ10gPSBoYXNGYWlsdXJlID8gJ3VuaGVhbHRoeScgOiBoYXNXYXJuaW5nID8gJ2RlZ3JhZGVkJyA6ICdoZWFsdGh5JztcblxuICAgICAgICB0aGlzLmxhc3RIZWFsdGggPSB7XG4gICAgICAgICAgICBzdGF0dXM6IG92ZXJhbGxTdGF0dXMsXG4gICAgICAgICAgICBycGNDb25uZWN0ZWQ6IGNoZWNrcy5maW5kKGMgPT4gYy5uYW1lID09PSAnUlBDIENvbm5lY3Rpdml0eScpPy5zdGF0dXMgPT09ICdwYXNzJyxcbiAgICAgICAgICAgIGNvbnRyYWN0Q29uZmlndXJlZDogY29uZmlnLmlzQ29uZmlndXJlZCxcbiAgICAgICAgICAgIHByb3ZlclJlYWR5LFxuICAgICAgICAgICAgbGFzdEhlYWx0aENoZWNrOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgY2hlY2tzXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICBvdmVyYWxsU3RhdHVzID09PSAnaGVhbHRoeScgPyAnaW5mbycgOiBvdmVyYWxsU3RhdHVzID09PSAnZGVncmFkZWQnID8gJ3dhcm4nIDogJ2Vycm9yJyxcbiAgICAgICAgICAgICdIZWFsdGgnLFxuICAgICAgICAgICAgYFN5c3RlbSBzdGF0dXM6ICR7b3ZlcmFsbFN0YXR1c31gLFxuICAgICAgICAgICAgeyBjaGVja3M6IGNoZWNrcy5tYXAoYyA9PiAoeyBuYW1lOiBjLm5hbWUsIHN0YXR1czogYy5zdGF0dXMgfSkpIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0SGVhbHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBsYXN0IGhlYWx0aCBjaGVjayByZXN1bHQgKGNhY2hlZClcbiAgICAgKi9cbiAgICBnZXRMYXN0SGVhbHRoKCk6IFN5c3RlbUhlYWx0aCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0SGVhbHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHBlcmlvZGljIGhlYWx0aCBjaGVja3NcbiAgICAgKi9cbiAgICBzdGFydEhlYWx0aENoZWNrcyhpbnRlcnZhbE1zID0gMzAwMDApIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMubG9nKCdpbmZvJywgJ0hlYWx0aCcsIGBTdGFydGluZyBoZWFsdGggY2hlY2tzIGV2ZXJ5ICR7aW50ZXJ2YWxNcyAvIDEwMDB9c2ApO1xuICAgICAgICB0aGlzLmNoZWNrSGVhbHRoKCk7IC8vIEluaXRpYWwgY2hlY2tcblxuICAgICAgICB0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrSGVhbHRoKCk7XG4gICAgICAgIH0sIGludGVydmFsTXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgaGVhbHRoIGNoZWNrc1xuICAgICAqL1xuICAgIHN0b3BIZWFsdGhDaGVja3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWx0aENoZWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFsdGhDaGVja0ludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvZygnaW5mbycsICdIZWFsdGgnLCAnSGVhbHRoIGNoZWNrcyBzdG9wcGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZm9ybWF0dGVkIHVwdGltZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRVcHRpbWVTdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdXB0aW1lID0gRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IodXB0aW1lIC8gMzYwMDAwMCk7XG4gICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKCh1cHRpbWUgJSAzNjAwMDAwKSAvIDYwMDAwKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IoKHVwdGltZSAlIDYwMDAwKSAvIDEwMDApO1xuICAgICAgICByZXR1cm4gYCR7aG91cnN9aCAke21pbnV0ZXN9bSAke3NlY29uZHN9c2A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3J0IG1ldHJpY3MgaW4gUHJvbWV0aGV1cyBmb3JtYXRcbiAgICAgKi9cbiAgICBnZXRQcm9tZXRoZXVzTWV0cmljcygpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5nZXRNZXRyaWNzKCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnIyBIRUxQIGNhc3Blcl9hY2NlbGVyYXRlX2JhdGNoZXNfdG90YWwgVG90YWwgbnVtYmVyIG9mIGJhdGNoZXMgcHJvY2Vzc2VkJyxcbiAgICAgICAgICAgICcjIFRZUEUgY2FzcGVyX2FjY2VsZXJhdGVfYmF0Y2hlc190b3RhbCBjb3VudGVyJyxcbiAgICAgICAgICAgIGBjYXNwZXJfYWNjZWxlcmF0ZV9iYXRjaGVzX3RvdGFsICR7bS50b3RhbEJhdGNoZXN9YCxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgSEVMUCBjYXNwZXJfYWNjZWxlcmF0ZV90cmFuc2FjdGlvbnNfdG90YWwgVG90YWwgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAnIyBUWVBFIGNhc3Blcl9hY2NlbGVyYXRlX3RyYW5zYWN0aW9uc190b3RhbCBjb3VudGVyJyxcbiAgICAgICAgICAgIGBjYXNwZXJfYWNjZWxlcmF0ZV90cmFuc2FjdGlvbnNfdG90YWwgJHttLnRvdGFsVHJhbnNhY3Rpb25zfWAsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICcjIEhFTFAgY2FzcGVyX2FjY2VsZXJhdGVfcHJvb2ZzX3RvdGFsIFRvdGFsIG51bWJlciBvZiBwcm9vZnMgZ2VuZXJhdGVkJyxcbiAgICAgICAgICAgICcjIFRZUEUgY2FzcGVyX2FjY2VsZXJhdGVfcHJvb2ZzX3RvdGFsIGNvdW50ZXInLFxuICAgICAgICAgICAgYGNhc3Blcl9hY2NlbGVyYXRlX3Byb29mc190b3RhbCAke20udG90YWxQcm9vZnNHZW5lcmF0ZWR9YCxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgSEVMUCBjYXNwZXJfYWNjZWxlcmF0ZV9wcm9vZl90aW1lX2F2Z19tcyBBdmVyYWdlIHByb29mIGdlbmVyYXRpb24gdGltZScsXG4gICAgICAgICAgICAnIyBUWVBFIGNhc3Blcl9hY2NlbGVyYXRlX3Byb29mX3RpbWVfYXZnX21zIGdhdWdlJyxcbiAgICAgICAgICAgIGBjYXNwZXJfYWNjZWxlcmF0ZV9wcm9vZl90aW1lX2F2Z19tcyAke20uYXZnUHJvb2ZUaW1lTXMudG9GaXhlZCgyKX1gLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAnIyBIRUxQIGNhc3Blcl9hY2NlbGVyYXRlX2wxX3N1Ym1pc3Npb25zX3RvdGFsIEwxIHN1Ym1pc3Npb24gYXR0ZW1wdHMnLFxuICAgICAgICAgICAgJyMgVFlQRSBjYXNwZXJfYWNjZWxlcmF0ZV9sMV9zdWJtaXNzaW9uc190b3RhbCBjb3VudGVyJyxcbiAgICAgICAgICAgIGBjYXNwZXJfYWNjZWxlcmF0ZV9sMV9zdWJtaXNzaW9uc190b3RhbHtyZXN1bHQ9XCJzdWNjZXNzXCJ9ICR7bS5sMVN1Ym1pc3Npb25zU3VjY2VlZGVkfWAsXG4gICAgICAgICAgICBgY2FzcGVyX2FjY2VsZXJhdGVfbDFfc3VibWlzc2lvbnNfdG90YWx7cmVzdWx0PVwiZmFpbHVyZVwifSAke20ubDFTdWJtaXNzaW9uRmFpbHVyZXN9YCxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJyMgSEVMUCBjYXNwZXJfYWNjZWxlcmF0ZV91cHRpbWVfc2Vjb25kcyBTeXN0ZW0gdXB0aW1lIGluIHNlY29uZHMnLFxuICAgICAgICAgICAgJyMgVFlQRSBjYXNwZXJfYWNjZWxlcmF0ZV91cHRpbWVfc2Vjb25kcyBnYXVnZScsXG4gICAgICAgICAgICBgY2FzcGVyX2FjY2VsZXJhdGVfdXB0aW1lX3NlY29uZHMgJHsobS51cHRpbWUgLyAxMDAwKS50b0ZpeGVkKDApfWBcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICB9XG59XG5cbi8vIFNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IG9ic2VydmFiaWxpdHkgPSBuZXcgT2JzZXJ2YWJpbGl0eVNlcnZpY2UoKTtcbiJdLCJuYW1lcyI6WyJDYXNwZXJTZXJ2aWNlIiwiT2JzZXJ2YWJpbGl0eVNlcnZpY2UiLCJsb2ciLCJsZXZlbCIsImNvbXBvbmVudCIsIm1lc3NhZ2UiLCJkYXRhIiwiZW50cnkiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwibG9ncyIsInB1c2giLCJsZW5ndGgiLCJtYXhMb2dzIiwic2xpY2UiLCJwcmVmaXgiLCJ0b0lTT1N0cmluZyIsInRvVXBwZXJDYXNlIiwiY29uc29sZSIsImVycm9yIiwid2FybiIsInByb2Nlc3MiLCJkZWJ1ZyIsInJlY29yZEJhdGNoUHJvY2Vzc2VkIiwiYmF0Y2hTaXplIiwibWV0cmljcyIsInRvdGFsQmF0Y2hlcyIsInRvdGFsVHJhbnNhY3Rpb25zIiwiYmF0Y2hTaXplcyIsImF2Z0JhdGNoU2l6ZSIsInJlZHVjZSIsImEiLCJiIiwidG9GaXhlZCIsInJlY29yZFByb29mR2VuZXJhdGVkIiwiZ2VuZXJhdGlvblRpbWVNcyIsInRvdGFsUHJvb2ZzR2VuZXJhdGVkIiwicHJvb2ZUaW1lcyIsImF2Z1Byb29mVGltZU1zIiwidG90YWxQcm9vZnMiLCJhdmdUaW1lIiwicmVjb3JkTDFTdWJtaXNzaW9uIiwic3VjY2VzcyIsImwxU3VibWlzc2lvbnNBdHRlbXB0ZWQiLCJsMVN1Ym1pc3Npb25zU3VjY2VlZGVkIiwibDFTdWJtaXNzaW9uRmFpbHVyZXMiLCJnZXRNZXRyaWNzIiwidXB0aW1lIiwic3RhcnRUaW1lIiwiZ2V0TG9ncyIsImxpbWl0IiwiZmlsdGVyZWRMb2dzIiwiZmlsdGVyIiwibCIsImNoZWNrSGVhbHRoIiwiY2hlY2tzIiwicnBjU3RhcnQiLCJzdGF0ZVJvb3QiLCJnZXRTdGF0ZVJvb3QiLCJuYW1lIiwic3RhdHVzIiwic3Vic3RyaW5nIiwibGF0ZW5jeU1zIiwiRXJyb3IiLCJjb25maWciLCJnZXRDb250cmFjdENvbmZpZyIsImlzQ29uZmlndXJlZCIsImNvbnRyYWN0SGFzaCIsInByb3ZlclJlYWR5IiwiYXZnQmF0Y2hUaW1lIiwic3VjY2Vzc1JhdGUiLCJoYXNGYWlsdXJlIiwic29tZSIsImMiLCJoYXNXYXJuaW5nIiwib3ZlcmFsbFN0YXR1cyIsImxhc3RIZWFsdGgiLCJycGNDb25uZWN0ZWQiLCJmaW5kIiwiY29udHJhY3RDb25maWd1cmVkIiwibGFzdEhlYWx0aENoZWNrIiwibWFwIiwiZ2V0TGFzdEhlYWx0aCIsInN0YXJ0SGVhbHRoQ2hlY2tzIiwiaW50ZXJ2YWxNcyIsImhlYWx0aENoZWNrSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInN0b3BIZWFsdGhDaGVja3MiLCJjbGVhckludGVydmFsIiwiZ2V0VXB0aW1lU3RyaW5nIiwiaG91cnMiLCJNYXRoIiwiZmxvb3IiLCJtaW51dGVzIiwic2Vjb25kcyIsImdldFByb21ldGhldXNNZXRyaWNzIiwibSIsImpvaW4iLCJjb25zdHJ1Y3RvciIsIm9ic2VydmFiaWxpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/observability.ts\n"));

/***/ })

});